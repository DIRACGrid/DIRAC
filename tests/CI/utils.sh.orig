<<<<<<< HEAD
#!/usr/bin/env bash
#...............................................................................
#
#   Copies local source and test code to docker containers, if they are
#       directories.
#   Requires $CLIENTCONFIG and $SERVERCONFIG to be defined.
#
#...............................................................................
function copyLocalSource() {
  CONTAINER_NAME=$1
  CONFIG_PATH=$2

  # shellcheck source=tests/CI/CONFIG
  source "$CONFIG_PATH"
  if [ -n "$TESTREPO" ] && [ -d "$TESTREPO" ]; then
    docker exec "${CONTAINER_NAME}" mkdir -p "$WORKSPACE/LocalRepo/TestCode"
    docker cp "$TESTREPO" "${CONTAINER_NAME}:$WORKSPACE/LocalRepo/TestCode"

    sed -i "s@\(export TESTREPO=\).*@\1${WORKSPACE}/LocalRepo/TestCode/$(basename "$TESTREPO")@" "$CONFIG_PATH"
  fi
  if [ -n "$ALTERNATIVE_MODULES" ] && [ -d "$ALTERNATIVE_MODULES" ]; then
    docker exec "${CONTAINER_NAME}" mkdir -p "$WORKSPACE/LocalRepo/ALTERNATIVE_MODULES"
    docker cp "$ALTERNATIVE_MODULES" "${CONTAINER_NAME}:$WORKSPACE/LocalRepo/ALTERNATIVE_MODULES"

    sed -i "s@\(export ALTERNATIVE_MODULES=\).*@\1${WORKSPACE}/LocalRepo/ALTERNATIVE_MODULES/$(basename "$ALTERNATIVE_MODULES")@" "$CONFIG_PATH"
  fi
}

=======
#!/bin/bash

#...............................................................................
#
# parseCommandLine:
#
#   parseCommandLine looks at the environment variables that are prefixed with 
#       DEFAULT_ and sets the unprefixed variable to the DEFAULT_* (default) value
#       if the unprefixed variable does not exists. Otherwise the unprefixed
#       variable is kept.
#   Should the variable $CONFIGFILE be defined, the parsed variables will be
#   exported to a sourceable file defined by $CONFIGFILE
#
#   Example:
#       DEFAULT_MYSQL_VER=5.7
#       MYSQL_VER not set ==> MYSQL_VER=5.7
#       ==== or ====
#       DEFAULT_MYSQL_VER=5.7
#       MYSQL_VER=8.0     ==> MYSQL_VER=8.0
#
#............................................................................... 
function parseCommandLine() {

    local DEFAULT_VARS=( ${!DEFAULT_@} )
    local DEFAULT_VAR
    
    for DEFAULT_VAR in "${DEFAULT_VARS[@]}"; do
        local VAR_NAME=${DEFAULT_VAR#"DEFAULT_"}
	
	if [ -z "${!VAR_NAME}" ]; then
	    local DEFAULT_VAL=${!DEFAULT_VAR}
	    eval $VAR_NAME="${DEFAULT_VAL}"
	    export $VAR_NAME
	    echo "Setting default value ${DEFAULT_VAL} for ${VAR_NAME}"
        else
	    local VAR_VAL="${!VAR_NAME}"
	    echo "Using injected value ${VAR_VAL} for ${VAR_NAME}"
	fi

	if [ ! -z $CONFIGFILE ]; then
	    echo "export ${VAR_NAME}=${!VAR_NAME}" >> $CONFIGFILE
	fi
    done
}


>>>>>>> migrate tests to real integration
#...............................................................................
#
# getLogs:
#
#   getLogs is an utility function that moves logs from spawned docker containers
#   to the $PWD
#
<<<<<<< HEAD
#...............................................................................
function getLogs() {
    docker cp server:/home/dirac/serverTestOutputs.txt ./log_server_tests.txt
    docker cp client:/home/dirac/clientTestOutputs.txt ./log_client_tests.txt
=======
#............................................................................... 
function getLogs() {
    USER=dirac
    USER_HOME=/home/$USER

    docker cp server:$USER_HOME/log.txt ./log_server_install.txt
    docker cp server:$USER_HOME/testOutputs.txt ./log_server_tests.txt
    docker cp client:$USER_HOME/log.txt ./log_client_install.txt
    docker cp client:$USER_HOME/testOutputs.txt ./log_client_tests.txt
>>>>>>> migrate tests to real integration
}
