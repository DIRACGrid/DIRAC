""" This is a test of the ProxyDB
    It supposes that the DB is present and installed in DIRAC
"""
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

# pylint: disable=invalid-name,wrong-import-position,protected-access
import os
import re
import sys
import stat
import shutil
import tempfile
import commands
import unittest

from diraccfg import CFG

from DIRAC.Core.Base.Script import parseCommandLine
parseCommandLine()

from DIRAC import gLogger, gConfig, S_OK, S_ERROR
from DIRAC.Core.Security.X509Chain import X509Chain  # pylint: disable=import-error
from DIRAC.FrameworkSystem.DB.ProxyDB import ProxyDB
from DIRAC.Resources.ProxyProvider.DIRACCAProxyProvider import DIRACCAProxyProvider

certsPath = os.path.join(os.environ['DIRAC'], 'DIRAC/Core/Security/test/certs')
ca = DIRACCAProxyProvider()
ca.setParameters({'CertFile': os.path.join(certsPath, 'ca/ca.cert.pem'),
                  'KeyFile': os.path.join(certsPath, 'ca/ca.key.pem')})

diracTestCACFG = """
Resources
{
  ProxyProviders
  {
    DIRAC_CA
    {
      ProviderType = DIRACCA
      CertFile = %s
      KeyFile = %s
      Supplied = C, O, OU, CN
      Optional = emailAddress
      DNOrder = C, O, OU, CN, emailAddress
      OU = None
      C = DN
      O = DIRACCA
    }
  }
}
""" % (os.path.join(certsPath, 'ca/ca.cert.pem'), os.path.join(certsPath, 'ca/ca.key.pem'))

usersDNs = {'user_ca': '/C=DN/O=DIRACCA/OU=None/CN=user_ca/emailAddress=user_ca@diracgrid.org',
            'user': '/C=CC/O=DN/O=DIRAC/CN=user',
            'no_user': '/C=CC/O=DN/O=DIRAC/CN=no_user',
            'user_1': '/C=CC/O=DN/O=DIRAC/CN=user_1',
            'user_2': '/C=CC/O=DN/O=DIRAC/CN=user_2',
            'user_3': '/C=CC/O=DN/O=DIRAC/CN=user_3',
            'user_4': '/C=CC/O=DN/O=DIRAC/CN=user_4'}

userCFG = """
Registry
{
  Users
  {
    # In dirac_user group
    user_ca
    {
      DN = /C=DN/O=DIRACCA/OU=None/CN=user_ca/emailAddress=user_ca@diracgrid.org
      DNProperties
      {
        DN.1
        {
          DN = /C=DN/O=DIRACCA/OU=None/CN=user_ca/emailAddress=user_ca@diracgrid.org
          ProxyProviders = DIRAC_CA
          Groups = dirac_user
        }
      }
    }
    user
    {
      DN = /C=CC/O=DN/O=DIRAC/CN=user
      DNProperties
      {
        DN.1
        {
          DN = /C=CC/O=DN/O=DIRAC/CN=user
          ProxyProviders =
          Groups = dirac_user
        }
      }
    }
    user_1
    {
      DN = /C=CC/O=DN/O=DIRAC/CN=user_1
      DNProperties
      {
        DN.1
        {
          DN = /C=CC/O=DN/O=DIRAC/CN=user_1
          ProxyProviders =
          Groups = dirac_user
        }
      }
    }
    user_2
    {
      DN = /C=CC/O=DN/O=DIRAC/CN=user_2
    }
    user_3
    {
      DN = /C=CC/O=DN/O=DIRAC/CN=user_3
    }
    # Not in dirac_user group
    user_4
    {
      DN = /C=CC/O=DN/O=DIRAC/CN=user_4
    }
  }
  Groups
  {
    group_1
    {
      Users = user_ca, user, user_1, user_2, user_3
      VO = vo_1
      VOMSRole = role_1
    }
    group_2
    {
      Users = user_4
      enableToDownload = False
    }
  }
  VO
  {
    vo_1
    {
      VOMSName = vo_1
      VOMSServers
      {
      }
    }
  }
}
"""

db = ProxyDB()


class ProxyDBTestCase(unittest.TestCase):

  @classmethod
  def createProxy(self, userName, group, time, vo=None, role=None):
    """ Create user proxy

        :param str userName: user name
        :param str group: group name
        :param int time: proxy expired time
        :param str vo: VOMS VO name
        :param str role: VOMS Role

        :return: S_OK(tuple)/S_ERROR() -- contain proxy as and as string
    """
    userCertFile = os.path.join(self.userDir, userName + '.cert.pem')
    userKeyFile = os.path.join(self.userDir, userName + '.key.pem')
    self.proxyPath = os.path.join(self.userDir, userName + '.pem')
    if not vo:
      chain = X509Chain()
      # Load user cert and key
      retVal = chain.loadChainFromFile(userCertFile)
      if not retVal['OK']:
        gLogger.warn(retVal['Message'])
        return S_ERROR("Can't load %s" % userCertFile)
      retVal = chain.loadKeyFromFile(userKeyFile)
      if not retVal['OK']:
        gLogger.warn(retVal['Message'])
        if 'bad decrypt' in retVal['Message']:
          return S_ERROR("Bad passphrase")
        return S_ERROR("Can't load %s" % userKeyFile)
      result = chain.generateProxyToFile(self.proxyPath, time * 3600, diracGroup=group)
      if not result['OK']:
        return result
    else:
      cmd = 'voms-proxy-fake --cert %s --key %s -q' % (userCertFile, userKeyFile)
      cmd += ' -hostcert %s -hostkey %s' % (self.hostCert, self.hostKey)
      cmd += ' -uri fakeserver.cern.ch:15000'
      cmd += ' -voms "%s"' % vo
      cmd += ' -fqan "/%s/Role=%s/Capability=NULL"' % (vo, role)
      cmd += ' -hours %s -out %s -rfc' % (time, self.proxyPath)
      status, output = commands.getstatusoutput(cmd)
      if status:
        return S_ERROR(output)
    chain = X509Chain()
    result = chain.loadProxyFromFile(self.proxyPath)
    if not result['OK']:
      return result
    result = chain.generateProxyToString(12 * 3600, diracGroup=group)
    if not result['OK']:
      return result
    return S_OK((chain, result['Value']))

  @classmethod
  def setUpClass(cls):
    cls.failed = False

    # Add configuration
    cfg = CFG()
    cfg.loadFromBuffer(diracTestCACFG)
    gConfig.loadCFG(cfg)
    cfg.loadFromBuffer(userCFG)
    gConfig.loadCFG(cfg)

    # Prepare CA
    lines = []
    cfgDict = {}
    cls.caPath = os.path.join(certsPath, 'ca')
    cls.caConfigFile = os.path.join(cls.caPath, 'openssl_config_ca.cnf')
    # Save original configuration file
    shutil.copyfile(cls.caConfigFile, cls.caConfigFile + 'bak')
    # Parse
    fields = ['dir', 'database', 'serial', 'new_certs_dir', 'private_key', 'certificate']
    with open(cls.caConfigFile, "r") as caCFG:
      for line in caCFG:
        if re.findall('=', re.sub(r'#.*', '', line)):
          field = re.sub(r'#.*', '', line).replace(' ', '').rstrip().split('=')[0]
          line = 'dir = %s #PUT THE RIGHT DIR HERE!\n' % (cls.caPath) if field == 'dir' else line
          val = re.sub(r'#.*', '', line).replace(' ', '').rstrip().split('=')[1]
          if field in fields:
            for i in fields:
              if cfgDict.get(i):
                val = val.replace('$%s' % i, cfgDict[i])
            cfgDict[field] = val
            if not cfgDict[field]:
              cls.failed = '%s have empty value in %s' % (field, cls.caConfigFile)
        lines.append(line)
    with open(cls.caConfigFile, "w") as caCFG:
      caCFG.writelines(lines)
    for field in fields:
      if field not in cfgDict.keys():
        cls.failed = '%s value is absent in %s' % (field, cls.caConfigFile)
    cls.hostCert = os.path.join(certsPath, 'host/hostcert.pem')
    cls.hostKey = os.path.join(certsPath, 'host/hostkey.pem')
    cls.caCert = cfgDict['certificate']
    cls.caKey = cfgDict['private_key']
    os.chmod(cls.caKey, stat.S_IREAD)
    # Check directory for new certificates
    cls.newCertDir = cfgDict['new_certs_dir']
    if not os.path.exists(cls.newCertDir):
      os.makedirs(cls.newCertDir)
    for f in os.listdir(cls.newCertDir):
      os.remove(os.path.join(cls.newCertDir, f))
    # Empty the certificate database
    cls.index = cfgDict['database']
    with open(cls.index, 'w') as indx:
      indx.write('')
    # Write down serial
    cls.serial = cfgDict['serial']
    with open(cls.serial, 'w') as serialFile:
      serialFile.write('1000')

    # Create temporaly directory for users certificates
    cls.userDir = tempfile.mkdtemp(dir=certsPath)

    # Create user certificates
    for userName in ['no_user', 'user', 'user_1', 'user_2', 'user_3']:
      userConf = """[ req ]
        default_bits           = 4096
        encrypt_key            = yes
        distinguished_name     = req_dn
        prompt                 = no
        req_extensions         = v3_req
        [ req_dn ]
        C                      = CC
        O                      = DN
        0.O                    = DIRAC
        CN                     = %s
        [ v3_req ]
        # Extensions for client certificates (`man x509v3_config`).
        nsComment = "OpenSSL Generated Client Certificate"
        keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment
        extendedKeyUsage = clientAuth
        """ % (userName)
      userConfFile = os.path.join(cls.userDir, userName + '.cnf')
      userReqFile = os.path.join(cls.userDir, userName + '.req')
      userKeyFile = os.path.join(cls.userDir, userName + '.key.pem')
      userCertFile = os.path.join(cls.userDir, userName + '.cert.pem')
      with open(userConfFile, "w") as f:
        f.write(userConf)
      status, output = commands.getstatusoutput('openssl genrsa -out %s' % userKeyFile)
      if status:
        gLogger.error(output)
        exit()
      gLogger.debug(output)
      os.chmod(userKeyFile, stat.S_IREAD)
      status, output = commands.getstatusoutput('openssl req -config %s -key %s -new -out %s' %
                                                (userConfFile, userKeyFile, userReqFile))
      if status:
        gLogger.error(output)
        exit()
      gLogger.debug(output)
      cmd = 'openssl ca -config %s -extensions usr_cert -batch -days 375 -in %s -out %s'
      cmd = cmd % (cls.caConfigFile, userReqFile, userCertFile)
      status, output = commands.getstatusoutput(cmd)
      if status:
        gLogger.error(output)
        exit()
      gLogger.debug(output)

    # Result
    status, output = commands.getstatusoutput('ls -al %s' % cls.userDir)
    if status:
      gLogger.error(output)
      exit()
    gLogger.debug('User certificates:\n', output)

  def setUp(self):
    gLogger.debug('\n')
    if self.failed:
       self.fail(self.failed)
    db._update('DELETE FROM ProxyDB_Proxies WHERE UserName IN ("%s")' % '", "'.join(usersDNs.keys()))
    db._update('DELETE FROM ProxyDB_CleanProxies WHERE UserDN IN ("%s")' % '", "'.join(usersDNs.values()))

  def tearDown(self):
    db._update('DELETE FROM ProxyDB_Proxies WHERE UserName IN ("%s")' % '", "'.join(usersDNs.keys()))
    db._update('DELETE FROM ProxyDB_CleanProxies WHERE UserDN IN ("%s")' % '", "'.join(usersDNs.values()))

  @classmethod
  def tearDownClass(cls):
    shutil.move(cls.caConfigFile + 'bak', cls.caConfigFile)
    if os.path.exists(cls.newCertDir):
      for f in os.listdir(cls.newCertDir):
        os.remove(os.path.join(cls.newCertDir, f))
    for f in os.listdir(cls.caPath):
      if re.match("%s..*" % cls.index, f) or f.endswith('.old'):
        os.remove(os.path.join(cls.caPath, f))
    if os.path.exists(cls.userDir):
      shutil.rmtree(cls.userDir)
    # Empty the certificate database
    with open(cls.index, 'w') as index:
      index.write('')
    # Write down serial
    with open(cls.serial, 'w') as serialFile:
      serialFile.write('1000')


class testDB(ProxyDBTestCase):

  def test_connectDB(self):
    """ Try to connect to the ProxyDB
    """
    res = db._connect()
    self.assertTrue(res['OK'])

  def test_getUsers(self):
    """ Test 'getUsers' - try to get users from DB
    """
    field = '(%%s"/C=CC/O=DN/O=DIRAC/CN=%%s", %%s "PEM", TIMESTAMPADD(SECOND, %%s, UTC_TIMESTAMP()))%s' % ''
    # Fill table for test
    gLogger.info('\n* Fill tables for test..')
    for table, values, fields in [('ProxyDB_Proxies',
                                  [field % ('"user", ', 'user', '"group_1",', '800'),
                                   field % ('"user_2", ', 'user_2', '"group_1",', '-1')],
                                  '(UserName, UserDN, UserGroup, Pem, ExpirationTime)'),
                                  ('ProxyDB_CleanProxies',
                                  [field % ('', 'user_3', '', '43200')],
                                  '(UserDN, Pem, ExpirationTime)')]:
      result = db._update('INSERT INTO %s%s VALUES %s ;' % (table, fields, ', '.join(values)))
      self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    # Testing 'getUsers'
    gLogger.info('\n* Run `purgeExpiredProxies()`..')
    for user, exp, expect, log in [(False, 0, ['user', 'user_2', 'user_3'], '\n* Without arguments'),
                                   (False, 1200, ['user_3'], '* Request proxy live time'),
                                   ('user_2', 0, ['user_2'], '* Request user name'),
                                   ('no_user', 0, [], '* Request not exist user name')]:
      gLogger.info('%s..' % log)
      result = db.getUsers(validSecondsLeft=exp, userMask=user)
      self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
      usersList = []
      for line in result['Value']:
        if line['user'] in ['user', 'user_2', 'user_3']:
          usersList.append(line['user'])
      self.assertEqual(set(expect), set(usersList), str(usersList) + ', when expected ' + str(expect))

  def test_purgeExpiredProxies(self):
    """ Test 'purgeExpiredProxies' - try to purge expired proxies
    """
    # Purge existed proxies
    gLogger.info('\n* First cleaning..')
    cmd = 'INSERT INTO ProxyDB_Proxies(UserName, UserDN, UserGroup, Pem, ExpirationTime) VALUES '
    cmd += '("user", "/C=CC/O=DN/O=DIRAC/CN=user", "group_1", "PEM", '
    cmd += 'TIMESTAMPADD(SECOND, -1, UTC_TIMESTAMP()));'
    result = db._query(cmd)
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    cmd = 'SELECT COUNT( * ) FROM ProxyDB_Proxies WHERE ExpirationTime < UTC_TIMESTAMP()'
    self.assertTrue(bool(db._query(cmd)['Value'][0][0] > 0))
    result = db.purgeExpiredProxies()
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    self.assertTrue(result['Value'] > 0, 'Must be more then null')
    self.assertFalse(bool(db._query(cmd)['Value'][0][0] > 0), "Must be null")

  def test_getRemoveProxy(self):
    """ Testing get, store proxy
    """
    gLogger.info('\n* Check that DB is clean..')
    result = db.getProxiesContent({'UserName': usersDNs.keys()})
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    self.assertTrue(bool(int(result['Value']['TotalRecords']) == 0), 'In DB present proxies.')

    gLogger.info('* Check posible crashes when get proxy..')
    # Make record with not valid proxy, valid group, user and short expired time
    cmd = 'INSERT INTO ProxyDB_Proxies(UserName, UserDN, UserGroup, Pem, ExpirationTime) VALUES '
    cmd += '("user", "/C=CC/O=DN/O=DIRAC/CN=user", "group_1", "PEM", '
    cmd += 'TIMESTAMPADD(SECOND, 1800, UTC_TIMESTAMP()));'
    result = db._update(cmd)
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    # Try to no correct getProxy requests
    for user, group, reqtime, log in [('user', 'group_1', 9999,
                                       'Not valid proxy, without proxy provider, with less lifetime'),
                                      ('user', 'group_1', 0,
                                       'Not valid proxy, without proxy provider, with good lifetime'),
                                      ('no_user', 'no_valid_group', 0,
                                       'User not exist, proxy not in DB tables'),
                                      ('user', 'no_valid_group', 0,
                                       'Group not valid, proxy not in DB tables'),
                                      ('user', 'group_1', 0,
                                       'Proxy removed from DB and not have a proxy provider'),
                                      ('user_4', 'group_2', 0,
                                       'Group has option enableToDownload = False in CS')]:
      gLogger.info('== > %s:' % log)
      result = db.getProxy(usersDNs[user], group, reqtime)
      self.assertFalse(result['OK'], 'Must be fail.')
      gLogger.info('Msg: %s' % result['Message'])
    # In the last case method found proxy and must to delete it as not valid
    cmd = 'SELECT COUNT( * ) FROM ProxyDB_Proxies WHERE UserName="user"'
    self.assertTrue(bool(db._query(cmd)['Value'][0][0] == 0), "GetProxy method didn't delete the last proxy.")

    gLogger.info('* Check that DB is clean..')
    result = db.getProxiesContent({'UserName': usersDNs.keys()})
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    self.assertTrue(bool(int(result['Value']['TotalRecords']) == 0), 'In DB present proxies.')

    gLogger.info('* Generate proxy on the fly..')
    result = db.getProxy(usersDNs['user_ca'], 'group_1', 1800)
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))

    gLogger.info('* Check that ProxyDB_CleanProxy contain generated proxy..')
    result = db.getProxiesContent({'UserName': 'user_ca'})
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    self.assertTrue(bool(int(result['Value']['TotalRecords']) == 1), 'Generated proxy must be one.')
    for table, count in [('ProxyDB_Proxies', 0), ('ProxyDB_CleanProxies', 1)]:
      cmd = 'SELECT COUNT( * ) FROM %s WHERE UserDN="%s"' % (table, usersDNs['user_ca'])
      self.assertTrue(bool(db._query(cmd)['Value'][0][0] == count),
                      table + ' must ' + (count and 'contain proxy' or 'be empty'))

    gLogger.info('* Check that DB is clean..')
    result = db.deleteProxy(usersDNs['user_ca'])
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    result = db.getProxiesContent({'UserName': usersDNs.keys()})
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    self.assertTrue(bool(int(result['Value']['TotalRecords']) == 0), 'In DB present proxies.')

    gLogger.info('* Upload proxy..')
    for user, dn, group, vo, time, res, log in [("user", usersDNs['user'], "group_1", False, 12,
                                                 False, 'With group extension'),
                                                ("user", usersDNs['user'], False, "vo_1", 12,
                                                 False, 'With voms extension'),
                                                ("user_1", usersDNs['user_1'], False, "vo_1", 12,
                                                 False, 'With voms extension'),
                                                ("user", usersDNs['user'], False, False, 0,
                                                 False, 'Expired proxy'),
                                                ("no_user", usersDNs['no_user'], False, False, 12,
                                                 False, 'Not exist user'),
                                                ("user", usersDNs['user'], False, False, 12,
                                                 True, 'Valid proxy')]:
      for table in ['ProxyDB_Proxies', 'ProxyDB_CleanProxies']:
        for _dn in [usersDNs['user'], usersDNs['user_1']]:
          result = db._update('DELETE FROM %s WHERE UserDN = "%s"' % (table, dn))
          self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))

      gLogger.info('== > %s:' % log)

      result = self.createProxy(user, group, time, vo=vo)
      self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
      chain = result['Value'][0]

      # Assert VOMSProxy
      if vo:
        self.assertTrue(bool(chain.isVOMS().get('Value')), 'Cannot create proxy with VOMS extension')

      result = db.generateDelegationRequest({'x509Chain': chain, 'DN': dn})
      self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
      resDict = result['Value']
      result = chain.generateChainFromRequestString(resDict['request'], time * 3500)
      self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
      if not chain.isVOMS().get('Value') and vo:
        gLogger.info('voms-proxy-fake command not working as expected, so proxy have no VOMS extention')
        res = not res
      result = db.completeDelegation(resDict['id'], dn, result['Value'])
      text = 'Must be ended %s%s' % (res and 'successful' or 'with error',
                                     ': %s' % result.get('Message', 'Error message is absent.'))
      self.assertEqual(result['OK'], res, text)
      if not res:
        gLogger.info('Msg: %s' % (result['Message']))
      cmd = 'SELECT COUNT( * ) FROM ProxyDB_Proxies WHERE UserName="%s"' % user
      self.assertTrue(bool(db._query(cmd)['Value'][0][0] == (res and group and 1) or 0),
                      'ProxyDB_Proxies must ' + (res and 'contain proxy' or 'be empty'))
      cmd = 'SELECT COUNT( * ) FROM ProxyDB_CleanProxies WHERE UserDN="%s"' % usersDNs[user]
      self.assertTrue(bool(db._query(cmd)['Value'][0][0] == (res and not group and 1) or 0),
                      'ProxyDB_CleanProxies must ' + (res and 'contain proxy' or 'be empty'))

    gLogger.info('* Check that ProxyDB_CleanProxy contain generated proxy..')
    result = db.getProxiesContent({'UserName': 'user'})
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    self.assertTrue(bool(int(result['Value']['TotalRecords']) == 1), 'Generated proxy must be one.')
    cmd = 'SELECT COUNT( * ) FROM ProxyDB_CleanProxies WHERE UserDN="%s"' % usersDNs[user]
    self.assertTrue(bool(db._query(cmd)['Value'][0][0] == 1), 'ProxyDB_CleanProxies must contain proxy')

    gLogger.info('* Get proxy that store only in ProxyDB_CleanProxies..')
    # Try to get proxy that was stored to ProxyDB_CleanProxies in previous step
    for res, group, reqtime, log in [(False, 'group_1', 24 * 3600, 'Request time more that in stored proxy'),
                                     (True, 'group_2', 0, 'Request group not contain user(this check on service side)'),
                                     (True, 'group_1', 0, 'Request time less that in stored proxy')]:
      gLogger.info('== > %s:' % log)
      result = db.getProxy(usersDNs['user'], group, reqtime)
      text = 'Must be ended %s%s' % (res and 'successful' or 'with error',
                                     ': %s' % result.get('Message', 'Error message is absent.'))
      self.assertEqual(result['OK'], res, text)
      if res:
        chain = result['Value'][0]
        self.assertTrue(chain.isValidProxy()['OK'], '\n' + result.get('Message', 'Error message is absent.'))
        result = chain.getDIRACGroup()
        self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
      else:
        gLogger.info('Msg: %s' % (result['Message']))

    gLogger.info('* Check that DB is clean..')
    result = db.deleteProxy(usersDNs['user'])
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    result = db.getProxiesContent({'UserName': usersDNs.keys()})
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    self.assertTrue(bool(int(result['Value']['TotalRecords']) == 0), 'In DB present proxies.')

    gLogger.info('* Get proxy when it store only in ProxyDB_Proxies..')
    # Make record with proxy that contain group
    result = ca._forceGenerateProxyForDN('/C=CC/O=DN/O=DIRAC/CN=user', 12 * 3600, group='group_1')
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    proxyStr = result['Value'][1]
    cmd = 'INSERT INTO ProxyDB_Proxies(UserName, UserDN, UserGroup, Pem, ExpirationTime) VALUES '
    cmd += '("user", "%s", "%s", "%s", TIMESTAMPADD(SECOND, 43200, UTC_TIMESTAMP()))' % (dn, group,
                                                                                           proxyStr)
    result = db._update(cmd)
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    # Try to get it
    result = db.getProxy(usersDNs[user], group, 1800)
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    # Check that proxy contain group
    chain = result['Value'][0]
    self.assertTrue(chain.isValidProxy()['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    result = chain.getDIRACGroup()
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    self.assertEqual('group_1', result['Value'], 'Group must be group_1, not ' + result['Value'])

    gLogger.info('* Check that DB is clean..')
    result = db.deleteProxy(usersDNs['user'])
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    result = db.getProxiesContent({'UserName': usersDNs.keys()})
    self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
    self.assertTrue(bool(int(result['Value']['TotalRecords']) == 0), 'In DB present proxies.')

    gLogger.info('* Get VOMS proxy..')
    for vomsuser in ['user', 'user_1']:
      # Create proxy with VOMS extension
      result = self.createProxy(vomsuser, 'group_1', 12, vo='vo_1', role='role_2')
      self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
      chain, proxyStr = result['Value']

      # Assert VOMSProxy
      self.assertTrue(bool(chain.isVOMS().get('Value')), 'Cannot create proxy with VOMS extension')

      cmd = 'INSERT INTO ProxyDB_Proxies(UserName, UserDN, UserGroup, Pem, ExpirationTime) VALUES '
      cmd += '("%s", "/C=CC/O=DN/O=DIRAC/CN=%s", "group_1", "%s", ' % (vomsuser, vomsuser, proxyStr)
      cmd += 'TIMESTAMPADD(SECOND, 43200, UTC_TIMESTAMP()))'
      result = db._update(cmd)
      self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))

    # Try to get proxy with VOMS extension
    for user, group, time, log in [('user_4', 'group_2', 9999,
                                    'Not exist VO for current group'),
                                   ('user', 'group_1', 9999,
                                    'Stored proxy already have different VOMS extension'),
                                   ('user_1', 'group_1', 9999,
                                    'Stored proxy already have different VOMS extension'),
                                   ('user_ca', 'group_1', 9999, 'Not correct VO configuration')]:
      gLogger.info('== > %s(DN: %s):' % (log, usersDNs[user]))
      result = db.getProxy(usersDNs[user], group, time, voms=True)
      self.assertFalse(result['OK'], 'Must be fail.')
      gLogger.info('Msg: %s' % result['Message'])
    # Check stored proxies
    for table, user, count in [('ProxyDB_Proxies', 'user', 1), ('ProxyDB_CleanProxies', 'user_ca', 1)]:
      cmd = 'SELECT COUNT( * ) FROM %s WHERE UserDN="%s"' % (table, usersDNs[user])
      self.assertTrue(bool(db._query(cmd)['Value'][0][0] == count))

    gLogger.info('* Delete proxies..')
    for user, table in [('user', 'ProxyDB_Proxies'),
                        ('user_ca', 'ProxyDB_CleanProxies')]:
      result = db.deleteProxy(usersDNs[user])
      self.assertTrue(result['OK'], '\n' + result.get('Message', 'Error message is absent.'))
      cmd = 'SELECT COUNT( * ) FROM %s WHERE UserDN="%s"' % (table, usersDNs[user])
      self.assertTrue(bool(db._query(cmd)['Value'][0][0] == 0))


if __name__ == '__main__':
  suite = unittest.defaultTestLoader.loadTestsFromTestCase(ProxyDBTestCase)
  suite.addTest(unittest.defaultTestLoader.loadTestsFromTestCase(testDB))
  testResult = unittest.TextTestRunner(verbosity=2).run(suite)
  sys.exit(not testResult.wasSuccessful())
